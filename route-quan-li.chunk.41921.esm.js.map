{"version":3,"sources":["webpack:///./components/sync/SurveyDisplayPagination.css","webpack:///./routes/quan-li.tsx","webpack:///./components/sync/SurveyDisplay.tsx","webpack:///../src/FileSaver.js","webpack:///./components/sync/SurveyDisplayPagination.tsx","webpack:///../node_modules/firebase-firestore-lite/dist/Transform.js","webpack:///../node_modules/firebase-firestore-lite/dist/utils.js","webpack:///../node_modules/firebase-firestore-lite/dist/Database.js","webpack:///../node_modules/firebase-firestore-lite/dist/GeoPoint.js","webpack:///../node_modules/firebase-firestore-lite/dist/Document.js","webpack:///../node_modules/firebase-firestore-lite/dist/Query.js","webpack:///../node_modules/firebase-firestore-lite/dist/List.js","webpack:///../node_modules/firebase-firestore-lite/dist/Reference.js","webpack:///../node_modules/firebase-firestore-lite/dist/Transaction.js","webpack:///./components/db/firestore.ts","webpack:///./components/sync/SurveyDisplay.css","webpack:///./components/sync/useMachineId.ts"],"names":["get_main_form_name","surveyType","fetchSurveys","async","offset","limit","surveys_list","db","list","orderBy","reverse","toArray","result","node","main_form","loadSurvey","surveyId","potential_person_name","data","ho_va_ten","a","name","push","QuanLi","skip","pageSize","parseInt","dataLoader","useAsync","loading","className","error","console","title","explain","message","surveys","setDbSyncStatusToDone","change","type","update","payload","syncStatus","SyncStatus","Synced","surveyForm","revision","surveyDataId","SyncProcessStatus","SurveyDisplay","total","setTotal","useState","count","setCount","syncProcessStatus","setStatus","Initial","machineId","useMachineId","syncData","useAsyncCallback","changes","PrepareData","Promise","all","where","NotSync","each","survey","length","Uploading","i","upsert","Done","notify","success","warn","style","wrapper","header","secondary","onClick","execute","disabled","bordered","fullWidth","scope","map","createdAt","key","epoch","format","Date","href","outline","forms_to_load","getAllSurveyForm","index","temp","blob","Blob","JSON","stringify","surveyData","saveAs","b","autoBom","test","c","d","XMLHttpRequest","open","responseType","onload","g","response","onerror","send","status","e","dispatchEvent","MouseEvent","document","createEvent","initMouseEvent","window","f","self","global","navigator","userAgent","HTMLAnchorElement","prototype","h","URL","webkitURL","j","createElement","download","rel","origin","location","target","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","body","innerText","HTMLElement","safari","FileReader","k","onloadend","replace","readAsDataURL","l","m","module","exports","SurveyDisplayPagination","state","setState","useEffect","then","catch","totalPage","Math","ceil","currentPage","floor","main","preventDefault","route","isNumber","v","isNaN","trimPath","path","trim","isPath","s","split","getPathFromRef","ref","_a","_b","_c","_d","Reference","Document","isRefType","TypeError","__meta__","restrictTo","isDoc","isPositiveInteger","val","Number","isInteger","objectToQuery","obj","parentProp","params","encode","encodeURIComponent","prop","undefined","propPath","Array","isArray","forEach","join","getKeyPaths","object","parentPath","mask","Transform","keyPath","concat","compileOptions","options","compiled","value","Object","entries","currentDocument","updateMask","fieldPaths","decodeValue","keys","values","decode","rootPath","GeoPoint","latitude","longitude","Error","fields","encodeValue","transforms","objectClass","toString","call","valueType","substring","toLowerCase","String","toISOString","toJSON","fieldPath","handleApiResponse","res","ok","json","constructor","this","geoPointValue","transformsMap","serverTimestamp","increment","max","min","appendToArray","removeFromArray","transformName","validator","arrayValue","rawDoc","createTime","updateTime","meta","id","pop","defineProperty","operatorsMap","contains","in","encoders","select","fieldsArray","encodeFilter","op","unaryFilter","field","fieldFilter","option","compositeFilter","filters","startAt","endAt","direction","documentToCursor","doc","order","referenceValue","before","queryOptions","Query","parent","init","isCollection","optionValue","from","collectionId","allDescendants","filter","arguments","validateFilter","dir","asc","desc","number","results","fetch","endpoint","method","splice","encoded","structuredQuery","List","rawList","documents","nextPageToken","pageToken","getNextPage","Symbol","iterator","next","done","isRoot","parentCollection","child","tx","transaction","commit","transact","query","Transaction","writes","preconditions","write","precondition","transform","fieldTransforms","refs","docs","batchGet","__missing__","exists","add","randBytes","crypto","getRandomValues","Uint8Array","fid","set","delete","projectId","auth","host","ssl","input","authorizedRequest","entry","found","missing","fn","attempts","collectionGroup","content","upsertSurvey","upsertData","ls","localStorage","getItem","makeId","setItem"],"mappings":"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","file":"route-quan-li.chunk.41921.esm.js","sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"main\":\"main__1K-lV\"};","import { db } from \"../components/db/db\";\nimport { useAsync } from \"react-async-hook\";\nimport { Spinner } from \"../components/spinner\";\nimport { Error } from \"../components/error\";\nimport { SurveyDisplay } from \"../components/sync/SurveyDisplay\";\nimport { SurveyType } from \"../components/types\"\nimport { loadSurvey } from \"../components/db/db_calls\";\n\nconst get_main_form_name = (surveyType: SurveyType) => {\n  switch (surveyType) {\n    case \"mau_giao\": return \"mau_giao_form\";\n    case \"tieu_hoc\": return \"tieu_hoc_form\";\n    case \"nguoi_lon\": return \"nguoi_lon_form\";\n  }\n}\nconst fetchSurveys = async (offset: number, limit: number) => {\n  let surveys_list = await db.list.orderBy(\"createdAt\").reverse().offset(offset).limit(limit).toArray();\n\n  const result = []\n  for (const node of surveys_list) {\n    const main_form = await loadSurvey(node.surveyId, get_main_form_name(node.surveyType));\n    const potential_person_name = main_form && main_form.data && main_form.data.ho_va_ten\n\n    let a = { ...node, name: potential_person_name };\n    result.push(a)\n  }\n  return result\n};\n\ninterface QuanLiProps {\n  skip: string;\n  pageSize: string;\n}\n\nconst QuanLi = ({ skip, pageSize }: QuanLiProps) => {\n  const offset = parseInt(skip, 10) || 0;\n  const limit = parseInt(pageSize, 10) || 50;\n\n  const dataLoader = useAsync(fetchSurveys, [offset, limit]);\n\n  if (dataLoader.loading) {\n    return (\n      <div className=\"wrapper\">\n        <Spinner />\n      </div>\n    );\n  } else if (dataLoader.error) {\n    console.error(dataLoader.error);\n    return (\n      <div className=\"wrapper\">\n        <Error title=\"Có lỗi xảy ra\" explain={dataLoader.error.message} />\n      </div>\n    );\n  } else if (dataLoader.result) {\n    const surveys = dataLoader.result;\n\n    return <SurveyDisplay surveys={surveys} offset={offset} limit={limit} />;\n  } else {\n    return (\n      <div className=\"wrapper\">\n        <Error title=\"Có lỗi xảy ra\" explain=\"Trường hợp này không hiểu tại sao xảy ra. quan-li.tsx:63\" />\n      </div>\n    );\n  }\n};\n\nexport default QuanLi;\n","\nimport style from \"./SurveyDisplay.css\";\nimport { useState } from \"react\";\nimport { Table, Button } from \"@trussworks/react-uswds\";\nimport { useAsyncCallback } from \"react-async-hook\";\nimport { Link } from \"preact-router/match\";\nimport { db, IDbSurvey, ISurveyData, SyncStatus } from \"../db/db\";\nimport { loadSurvey } from \"../db/db_calls\";\nimport { upsert, RemoteData } from \"../db/firestore\";\nimport { format } from \"date-fns\";\nimport { notify } from \"../notify\";\nimport { useMachineId } from \"./useMachineId\";\nimport { SurveyDisplayPagination } from \"./SurveyDisplayPagination\";\nimport { SurveyType } from \"../types\";\nimport {saveAs} from \"file-saver\"\nconst formatDate = (epoch: number) => {\n  return format(new Date(epoch), \"dd-MM-yyyy hh:mm:ss\");\n};\n\ninterface SurveyDisplayProps {\n  surveys: Array<IDbSurvey & { name: string | undefined }>;\n  offset: number;\n  limit: number;\n}\n\nenum SyncProcessStatus {\n  Initial = 0,\n  PrepareData = 1,\n  Uploading = 2,\n  Done = 3,\n}\n\nexport const SurveyDisplay: React.FC<SurveyDisplayProps> = ({ surveys, offset, limit }) => {\n  const [total, setTotal] = useState<number>(0);\n  const [count, setCount] = useState<number>(0);\n  const [syncProcessStatus, setStatus] = useState(SyncProcessStatus.Initial);\n  const machineId = useMachineId();\n\n  const syncData = useAsyncCallback(async () => {\n    try {\n      const changes: RemoteData[] = [];\n      setStatus(SyncProcessStatus.PrepareData);\n\n      await Promise.all([\n        db.list.where({ syncStatus: SyncStatus.NotSync }).each((survey) => {\n          changes.push({\n            type: \"survey\",\n            payload: survey,\n          });\n        }),\n        db.data.where({ syncStatus: SyncStatus.NotSync }).each((survey) => {\n          changes.push({\n            type: \"surveyData\",\n            payload: survey,\n          });\n        }),\n        db.revision.where({ syncStatus: SyncStatus.NotSync }).each((survey) => {\n          changes.push({\n            type: \"surveyRevision\",\n            payload: survey,\n          });\n        }),\n      ]);\n\n      setCount(0);\n      setTotal(changes.length);\n      setStatus(SyncProcessStatus.Uploading);\n\n      for (let i = 0; i < changes.length; i++) {\n        const change: RemoteData = changes[i];\n        await upsert(change, machineId);\n\n        await setDbSyncStatusToDone(change);\n        setCount((count) => count + 1);\n      }\n\n      setStatus(SyncProcessStatus.Done);\n      if (count === total) {\n        notify.success(\"Đồng bộ dữ liệu thành công\");\n      } else {\n        notify.warn(`Có lỗi xảy ra khi đồng bộ. Chỉ đồng bộ được ${count}/${total} hồ sơ`);\n      }\n    } catch (error) {\n      console.error(error);\n      notify.error(\"Có lỗi xảy ra khi đồng bộ dữ liệu\");\n    }\n  });\n\n  return (\n    <div className={style.wrapper}>\n      <header className={style.header}>\n        <h1>Quản lí hồ sơ</h1>\n        <Button type=\"button\" secondary onClick={syncData.execute} disabled={syncData.loading}>\n          Đồng bộ\n        </Button>\n      </header>\n\n      {syncProcessStatus === SyncProcessStatus.PrepareData && (\n        <div className={style.syncStatus}>\"Đang tìm dữ liệu....\"</div>\n      )}\n      {syncProcessStatus === SyncProcessStatus.Uploading && (\n        <div className={style.syncStatus}>\n          <span>\n            Tải dữ liệu lên {count}/{total}\n          </span>\n        </div>\n      )}\n      {syncProcessStatus === SyncProcessStatus.Done && (\n        <div className={style.syncStatus}>\n          <span>Đồng bộ thành công</span>\n        </div>\n      )}\n      <SurveyDisplayPagination offset={offset} limit={limit} />\n      <Table bordered fullWidth>\n        <thead>\n          <tr>\n            <th scope=\"col\">Mã số</th>\n            <th scope=\"col\">Loại hồ sơ</th>\n            <th scope=\"col\">Tên</th>\n            <th scope=\"col\">Thời gian tạo</th>\n            <td></td>\n          </tr>\n        </thead>\n        <tbody>\n          {surveys.map(({ surveyId, surveyType, name, createdAt }) => (\n            <tr key={surveyId}>\n              <td>{surveyId}</td>\n              <td>{surveyType}</td>\n              <td>{name}</td>\n              <td>{formatDate(createdAt)}</td>\n              <td>\n                <Link href={`/survey/${surveyId}`}>\n                  <Button type=\"button\">Xem</Button>\n                </Link>\n                <Button\n                  type=\"button\"\n                  outline\n                  onClick={async (e) => {\n                    let forms_to_load = getAllSurveyForm(surveyType);\n                    let result = [];\n                    for (const index in forms_to_load) {\n                      let temp = await loadSurvey(surveyId, forms_to_load[index]);\n                      result.push(temp)\n                    }\n                    let dataToDownload = {surveyId, surveyType, surveyData: result}\n                    var blob = new Blob([JSON.stringify(dataToDownload)], {type: \"text/plain;charset=utf-8\"});\n                    saveAs(blob, `${name}_${surveyId}.voser`)\n                  }}\n                >\n                  Tải về\n                </Button>\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </Table>\n      <SurveyDisplayPagination offset={offset} limit={limit} />\n    </div>\n  );\n};\n\nasync function setDbSyncStatusToDone(change: RemoteData) {\n  switch (change.type) {\n    case \"survey\":\n      await db.list.update(change.payload.surveyId, { syncStatus: SyncStatus.Synced });\n      break;\n    case \"surveyData\":\n      await db.data.update([change.payload.surveyId, change.payload.surveyForm], {\n        syncStatus: SyncStatus.Synced,\n      });\n      break;\n\n    case \"surveyRevision\":\n      await db.revision.update(change.payload.surveyDataId, {\n        syncStatus: SyncStatus.Synced,\n      });\n      break;\n  }\n}\n\nfunction getAllSurveyForm(survey: SurveyType) {\n  switch (survey) {\n    case \"mau_giao\":\n      return [\"mau_giao_form\"];\n    case \"tieu_hoc\":\n      return [\"tieu_hoc_form\", \"tieu_hoc_questionare\", \"tieu_hoc_child_oidp\"];\n    case \"nguoi_lon\":\n      return [\"nguoi_lon_form\", \"nguoi_lon_questionare\", \"nguoi_lon_ohip14\"];\n  }\n}\n","/*\n* FileSaver.js\n* A saveAs() FileSaver implementation.\n*\n* By Eli Grey, http://eligrey.com\n*\n* License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)\n* source  : http://purl.eligrey.com/github/FileSaver.js\n*/\n\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nvar _global = typeof window === 'object' && window.window === window\n  ? window : typeof self === 'object' && self.self === self\n  ? self : typeof global === 'object' && global.global === global\n  ? global\n  : this\n\nfunction bom (blob, opts) {\n  if (typeof opts === 'undefined') opts = { autoBom: false }\n  else if (typeof opts !== 'object') {\n    console.warn('Deprecated: Expected third argument to be a object')\n    opts = { autoBom: !opts }\n  }\n\n  // prepend BOM for UTF-8 XML and text/* types (including HTML)\n  // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n  if (opts.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type })\n  }\n  return blob\n}\n\nfunction download (url, name, opts) {\n  var xhr = new XMLHttpRequest()\n  xhr.open('GET', url)\n  xhr.responseType = 'blob'\n  xhr.onload = function () {\n    saveAs(xhr.response, name, opts)\n  }\n  xhr.onerror = function () {\n    console.error('could not download file')\n  }\n  xhr.send()\n}\n\nfunction corsEnabled (url) {\n  var xhr = new XMLHttpRequest()\n  // use sync to avoid popup blocker\n  xhr.open('HEAD', url, false)\n  try {\n    xhr.send()\n  } catch (e) {}\n  return xhr.status >= 200 && xhr.status <= 299\n}\n\n// `a.click()` doesn't work for all browsers (#465)\nfunction click (node) {\n  try {\n    node.dispatchEvent(new MouseEvent('click'))\n  } catch (e) {\n    var evt = document.createEvent('MouseEvents')\n    evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80,\n                          20, false, false, false, false, 0, null)\n    node.dispatchEvent(evt)\n  }\n}\n\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nvar isMacOSWebView = _global.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent)\n\nvar saveAs = _global.saveAs || (\n  // probably in some web worker\n  (typeof window !== 'object' || window !== _global)\n    ? function saveAs () { /* noop */ }\n\n  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView\n  : ('download' in HTMLAnchorElement.prototype && !isMacOSWebView)\n  ? function saveAs (blob, name, opts) {\n    var URL = _global.URL || _global.webkitURL\n    var a = document.createElement('a')\n    name = name || blob.name || 'download'\n\n    a.download = name\n    a.rel = 'noopener' // tabnabbing\n\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n\n    if (typeof blob === 'string') {\n      // Support regular links\n      a.href = blob\n      if (a.origin !== location.origin) {\n        corsEnabled(a.href)\n          ? download(blob, name, opts)\n          : click(a, a.target = '_blank')\n      } else {\n        click(a)\n      }\n    } else {\n      // Support blobs\n      a.href = URL.createObjectURL(blob)\n      setTimeout(function () { URL.revokeObjectURL(a.href) }, 4E4) // 40s\n      setTimeout(function () { click(a) }, 0)\n    }\n  }\n\n  // Use msSaveOrOpenBlob as a second approach\n  : 'msSaveOrOpenBlob' in navigator\n  ? function saveAs (blob, name, opts) {\n    name = name || blob.name || 'download'\n\n    if (typeof blob === 'string') {\n      if (corsEnabled(blob)) {\n        download(blob, name, opts)\n      } else {\n        var a = document.createElement('a')\n        a.href = blob\n        a.target = '_blank'\n        setTimeout(function () { click(a) })\n      }\n    } else {\n      navigator.msSaveOrOpenBlob(bom(blob, opts), name)\n    }\n  }\n\n  // Fallback to using FileReader and a popup\n  : function saveAs (blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank')\n    if (popup) {\n      popup.document.title =\n      popup.document.body.innerText = 'downloading...'\n    }\n\n    if (typeof blob === 'string') return download(blob, name, opts)\n\n    var force = blob.type === 'application/octet-stream'\n    var isSafari = /constructor/i.test(_global.HTMLElement) || _global.safari\n    var isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent)\n\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) && typeof FileReader !== 'undefined') {\n      // Safari doesn't allow downloading of blob URLs\n      var reader = new FileReader()\n      reader.onloadend = function () {\n        var url = reader.result\n        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;')\n        if (popup) popup.location.href = url\n        else location = url\n        popup = null // reverse-tabnabbing #460\n      }\n      reader.readAsDataURL(blob)\n    } else {\n      var URL = _global.URL || _global.webkitURL\n      var url = URL.createObjectURL(blob)\n      if (popup) popup.location = url\n      else location.href = url\n      popup = null // reverse-tabnabbing #460\n      setTimeout(function () { URL.revokeObjectURL(url) }, 4E4) // 40s\n    }\n  }\n)\n\n_global.saveAs = saveAs.saveAs = saveAs\n\nif (typeof module !== 'undefined') {\n  module.exports = saveAs;\n}\n","\nimport { useState, useEffect } from \"react\";\nimport { AsyncAction } from \"../types\";\nimport { db } from \"../db/db\";\nimport { Error } from \"../error\";\nimport { route } from \"preact-router\";\nimport style from \"./SurveyDisplayPagination.css\";\n\ninterface SurveyDisplayPaginationProps {\n  offset: number;\n  limit: number;\n}\n\ntype State = AsyncAction<number, string>;\n\nexport const SurveyDisplayPagination: React.FC<SurveyDisplayPaginationProps> = ({ offset, limit }) => {\n  const [state, setState] = useState<State>({ type: \"initial\" });\n\n  useEffect(() => {\n    db.list\n      .count()\n      .then((result) => setState({ type: \"success\", payload: result }))\n      .catch((error) => {\n        console.error(error);\n        setState({ type: \"error\", payload: error.message });\n      });\n  }, []);\n\n  switch (state.type) {\n    case \"initial\":\n    case \"loading\":\n      return null;\n    case \"success\":\n      const total = state.payload;\n      const totalPage = Math.ceil(total / limit);\n      const currentPage = Math.floor(offset / limit) + 1;\n\n      return (\n        <div className={style.main}>\n          <button\n            type=\"button\"\n            onClick={(e) => {\n              e.preventDefault();\n              route(`/quan_li/${(currentPage - 2) * limit}/${limit}`);\n            }}\n            disabled={currentPage <= 1}\n          >\n            Trang trước ←\n          </button>\n          <span>\n            Trang {currentPage}/{totalPage} ({total} hồ sơ tất cả)\n          </span>\n          <button\n            type=\"button\"\n            onClick={(e) => {\n              e.preventDefault();\n              route(`/quan_li/${currentPage * limit}/${limit}`);\n            }}\n            disabled={currentPage >= totalPage}\n          >\n            Trang tiếp →\n          </button>\n        </div>\n      );\n\n    case \"error\":\n      return (\n        <div className=\"wrapper\">\n          <Error title=\"Đã có lỗi xảy ra\" explain={state.payload} />\n        </div>\n      );\n  }\n};\n","import { encodeValue } from './utils';\n/** @private */\nfunction isNumber(v) {\n    return typeof v === 'number' && !isNaN(v - v);\n}\n/** @private */\nconst transformsMap = {\n    serverTimestamp: ['setToServerValue'],\n    increment: ['increment', isNumber],\n    max: ['maximum', isNumber],\n    min: ['minimum', isNumber],\n    appendToArray: ['appendMissingElements', Array.isArray],\n    removeFromArray: ['removeAllFromArray', Array.isArray]\n};\n/**\n * Represents a value that is the result of an operation\n * made by the Firebase server. For example `serverTimestamp`\n * can't be known in the client, as it evaluates in the server.\n */\nexport default class Transform {\n    /**\n     * @param value when applicable, the value will be used.\n     * for example when using `increment` the value will be the number to increment by.\n     */\n    constructor(name, value) {\n        if (!(name in transformsMap))\n            throw Error(`Invalid transform name: \"${name}\"`);\n        const [transformName, validator] = transformsMap[name];\n        if (validator && !validator(value))\n            throw Error(`The value for the transform \"${name}\" needs to be a${validator === isNumber ? ' number' : 'n array'}.`);\n        if (validator === Array.isArray)\n            this[transformName] = encodeValue(value).arrayValue;\n        else\n            this[transformName] =\n                name === 'serverTimestamp' ? 'REQUEST_TIME' : encodeValue(value);\n    }\n}\n","import { Reference } from './Reference';\nimport GeoPoint from './GeoPoint';\nimport Transform from './Transform';\nimport { Document } from './Document';\n/**\n * Used for generating random fids.\n * @private\n */\nconst validChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';\n/**\n * Trims spaces and slashes from a path\n * @private\n */\nexport function trimPath(path) {\n    return path.trim().replace(/^\\/?/, '').replace(/\\/?$/, '');\n}\n/**\n * Returns true if a variable is a path that points to a collection\n * @private\n */\nexport function isPath(type, s) {\n    return (typeof s === 'string' &&\n        s !== '' &&\n        trimPath(s).split('/').length % 2 === (type === 'doc' ? 0 : 1));\n}\n/**\n * Checks if a value is a Reference to a Document\n * @private\n */\nexport function isRef(type, val) {\n    return (val instanceof Reference &&\n        (type === 'doc' ? !val.isCollection : val.isCollection));\n}\n/** @private */\nexport function isRefType(ref) {\n    return (ref instanceof Reference ||\n        ref instanceof Document ||\n        typeof ref === 'string');\n}\n/** @private */\nexport function getPathFromRef(ref) {\n    var _a, _b, _c, _d;\n    if (!isRefType(ref))\n        throw TypeError('Expected a Reference, Document or a path but got something else');\n    return ((_d = (_c = (_b = (_a = ref) === null || _a === void 0 ? void 0 : _a.__meta__) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : ref.path) !== null && _d !== void 0 ? _d : trimPath(ref));\n}\n/** @private */\nexport function restrictTo(type, ref) {\n    const isDoc = type === 'doc';\n    const path = getPathFromRef(ref);\n    if (!isPath(type, path))\n        throw TypeError(`You are trying to access a method reserved for ${isDoc ? 'Documents' : 'Collections'} with a ${isDoc ? 'Collection' : 'Document'}`);\n    return path;\n}\n/**\n * Checks if a value is a number that is not negative and is an integer\n * @private\n */\nexport function isPositiveInteger(val) {\n    return Number.isInteger(val) && val >= 0;\n}\n/**\n * Converts an Object to a URI query String\n * @private\n */\nexport function objectToQuery(obj = {}, parentProp) {\n    const params = [];\n    const encode = encodeURIComponent;\n    for (const prop in obj) {\n        if (obj[prop] === undefined)\n            continue; // Skip over undefined props.\n        const propPath = parentProp ? `${parentProp}.${prop}` : prop;\n        // If it is an array then we should encode each value independently, and then join.\n        if (Array.isArray(obj[prop])) {\n            obj[prop].forEach((v) => {\n                params.push(`${propPath}=${encode(v)}`);\n            });\n            continue;\n        }\n        if (typeof obj[prop] === 'object') {\n            const val = objectToQuery(obj[prop], propPath);\n            val && params.push(val);\n            continue;\n        }\n        params.push(`${propPath}=${encode(obj[prop])}`);\n    }\n    return (!parentProp && params.length ? '?' : '') + params.join('&');\n}\n/**\n * Returns an array of keyPaths of an object but skips over array's values\n * @private\n */\nexport function getKeyPaths(object, parentPath) {\n    let mask = [];\n    for (const key in object) {\n        if (object[key] instanceof Transform)\n            continue;\n        const keyPath = parentPath ? `${parentPath}.${key}` : key;\n        // Only check child props if the value is an object,\n        // but not null or arrays.\n        if (object[key] !== null &&\n            typeof object[key] === 'object' &&\n            !Array.isArray(object[key]) &&\n            !(object[key] instanceof Date)) {\n            mask = mask.concat(getKeyPaths(object[key], keyPath));\n            continue;\n        }\n        mask.push(keyPath);\n    }\n    return mask;\n}\n/**\n * Compile options object into firebase valid api arguments object\n * @private\n */\nexport function compileOptions(options, obj) {\n    const compiled = {};\n    for (let [key, value] of Object.entries(options)) {\n        if (value === undefined)\n            continue;\n        switch (key) {\n            case 'exists':\n            case 'updateTime':\n                if (!compiled.currentDocument)\n                    compiled.currentDocument = {};\n                compiled.currentDocument[key] = value;\n                break;\n            case 'updateMask':\n                if (!obj)\n                    break;\n                if (value)\n                    compiled.updateMask = { fieldPaths: getKeyPaths(obj) };\n                break;\n            case 'mask':\n                compiled.mask = { fieldPaths: value };\n                break;\n            default:\n                compiled[key] = value;\n        }\n    }\n    return compiled;\n}\n/**\n * Decodes a Firebase Value into a JS one\n * @private\n */\nfunction decodeValue(value, db) {\n    // Get the value type.\n    const type = Object.keys(value)[0];\n    // Replace the firebase raw value, with actual value inside of it.\n    value = value[type];\n    // Some values need to be handled in a specific way,\n    // check if this is one of them, and return the value.\n    switch (type) {\n        case 'integerValue':\n            return Number(value);\n        case 'arrayValue':\n            return value.values\n                ? value.values.map((val) => decodeValue(val, db))\n                : [];\n        case 'mapValue':\n            return decode(value, db);\n        case 'timestampValue':\n            return new Date(value);\n        case 'referenceValue':\n            return new Reference(value.replace(db.rootPath, ''), db);\n        case 'geoPointValue':\n            return new GeoPoint(value.latitude, value.longitude);\n        // These are the rest of the values.\n        // We include all of them instead of using 'default:'\n        // because we use it as validation.\n        case 'stringValue':\n        case 'doubleValue':\n        case 'booleanValue':\n        case 'nullValue':\n        case 'bytesValue':\n            return value;\n    }\n    // If none matched throw.\n    throw Error(`Invalid Firestore value_type \"${type}\"`);\n}\n/**\n * Decodes a Firebase map into a JS object\n * @private\n */\nexport function decode(map, db) {\n    if (db === undefined)\n        throw Error('Argument \"db\" is required but missing');\n    const object = {};\n    for (const key in map.fields) {\n        object[key] = decodeValue(map.fields[key], db);\n    }\n    return object;\n}\n/**\n * Encodes a JS variable into a Firebase Value\n * @private\n */\nexport function encodeValue(value, transforms, parentPath) {\n    const objectClass = Object.prototype.toString.call(value);\n    let valueType = objectClass.substring(8, objectClass.length - 1).toLowerCase() + 'Value';\n    switch (valueType) {\n        case 'numberValue':\n            valueType = Number.isInteger(value) ? 'integerValue' : 'doubleValue';\n            value = valueType === 'integerValue' ? String(value) : value;\n            break;\n        case 'arrayValue':\n            value = value.length ? { values: value.map(encodeValue) } : {};\n            break;\n        case 'dateValue':\n            valueType = 'timestampValue';\n            value = value.toISOString();\n            break;\n        case 'objectValue':\n            // If the object is a custom type, then use its built in encoder\n            // and return it.\n            if (value instanceof Reference || value instanceof GeoPoint)\n                return value.toJSON();\n            // Else assume its intended to be a Map value.\n            valueType = 'mapValue';\n            value = encode(value, transforms, parentPath);\n            break;\n    }\n    return { [valueType]: value };\n}\n/**\n * Converts a Javascript object into a write instruction\n * @private\n */\nexport function encode(object, transforms, parentPath) {\n    const keys = Object.keys(object);\n    if (keys.length === 0)\n        return {};\n    const map = { fields: {} };\n    for (const key of keys) {\n        if (object[key] === undefined)\n            continue;\n        const value = object[key];\n        const path = parentPath ? `${parentPath}.${key}` : key;\n        // If this is a transform then add it to the transforms\n        // list and skip its parsing. but only if a transforms array\n        // was provided.\n        if (value instanceof Transform) {\n            value.fieldPath = path;\n            transforms && transforms.push(value);\n            continue;\n        }\n        map.fields[key] = encodeValue(value, transforms, path);\n    }\n    return map;\n}\n/**\n * Generates 22 chars long random alphanumerics unique identifiers\n * @private\n */\nexport function fid() {\n    const randBytes = crypto.getRandomValues(new Uint8Array(20));\n    return Array.from(randBytes)\n        .map(b => validChars[b % 63])\n        .join('');\n}\n","import { Reference } from './Reference';\nimport { Document } from './Document';\nimport { restrictTo } from './utils';\nimport { Transaction } from './Transaction';\nimport { Query } from './Query';\n/** @private */\nasync function handleApiResponse(res) {\n    if (!res.ok) {\n        const data = await res.json();\n        if (Array.isArray(data))\n            throw data.length === 1\n                ? Object.assign(new Error(), data[0].error)\n                : data;\n        throw Object.assign(new Error(), data.error);\n    }\n    return res.json();\n}\n/** Database Instance */\nexport class Database {\n    constructor({ projectId, auth, name = '(default)', host = 'firestore.googleapis.com', ssl = true }) {\n        if (projectId === undefined)\n            throw Error('Database constructor expected the \"config\" argument to have a valid \"projectId\" property');\n        this.name = name;\n        this.auth = auth;\n        this.rootPath = `projects/${projectId}/databases/${name}/documents`;\n        this.endpoint = `http${ssl ? 's' : ''}://${host}/v1/${this.rootPath}`;\n    }\n    /**\n     * For internal use only.\n     * Uses native fetch, but adds authorization headers\n     * if the Reference was instantiated with an auth instance.\n     * The API is exactly the same as native fetch.\n     * @private\n     */\n    fetch(input, init) {\n        if (this.auth && this.auth.authorizedRequest)\n            return this.auth.authorizedRequest(input, init).then(handleApiResponse);\n        return fetch(input, init).then(handleApiResponse);\n    }\n    /**\n     * Returns a reference to a document or a collection.\n     * @param {(string|Document)} path Path to the collection or document.\n     * @returns {Reference} instance of a reference.\n     */\n    ref(path) {\n        if (path instanceof Document)\n            path = path.__meta__.path;\n        return new Reference(path, this);\n    }\n    async batchGet(refs) {\n        const response = await this.fetch(this.endpoint + ':batchGet', {\n            method: 'POST',\n            body: JSON.stringify({\n                documents: refs.map(ref => {\n                    const path = restrictTo('doc', ref);\n                    return `${this.rootPath}/${path}`;\n                })\n            })\n        });\n        return response.map((entry) => entry.found\n            ? new Document(entry.found, this)\n            : Object.defineProperty({}, '__missing__', { value: entry.missing }));\n    }\n    /** Returns a new transaction instance */\n    transaction() {\n        return new Transaction(this);\n    }\n    /**\n     * Executes the given `updateFunction` and attempts to commit\n     * the changes applied within it as a Transaction. If any document\n     * read within the transaction has changed, Cloud Firestore retries\n     * the updateFunction. If it fails to commit after 5 attempts, the\n     * transaction fails and throws.\n     *\n     * Will not re-attempt if an error is thrown inside the `updateFunction`\n     * or if any error that is not related to the transaction is received\n     * like a network error etc.\n     */\n    async runTransaction(fn, attempts = 5) {\n        const tx = new Transaction(this);\n        while (attempts > 0) {\n            await fn(tx);\n            // Only retry on transaction errors.\n            try {\n                await tx.commit();\n                break; // Stop trying if it succeeded.\n            }\n            catch (e) {\n                // Only throw if the error is not related to the transaction, or it is the last attempt.\n                if (attempts === 0 ||\n                    (e.status !== 'NOT_FOUND' && e.status !== 'FAILED_PRECONDITION'))\n                    throw Error(e);\n            }\n            attempts--;\n        }\n    }\n    /**\n     * Query all all collections that match the given name that\n     * also are descendants of a given document (or root by default).\n     */\n    collectionGroup(collectionId, options = {}) {\n        return new Query(this.ref('parent' in options ? options.parent : ''), {\n            from: {\n                collectionId,\n                allDescendants: true\n            },\n            ...options\n        });\n    }\n}\n","/** Represents a firebase GeoPoint value */\nexport default class GeoPoint {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n        if (typeof latitude !== 'number')\n            throw Error('The latitude argument should be of type number');\n        if (typeof latitude !== 'number')\n            throw Error('The longitude argument should be of type number');\n        if (latitude >= 90 || latitude <= -90)\n            throw Error(\"GeoPoint's latitude should be within the range of -90.0 and 90.0\");\n        if (longitude >= 180 || longitude <= -180)\n            throw Error(\"GeoPoint's longitude should be within the range of -180.0 and 180.0\");\n    }\n    toJSON() {\n        return {\n            geoPointValue: { ...this }\n        };\n    }\n}\n","import { decode } from './utils';\n/**\n * Wrapper around a fetched objects that represent a Firestore document.\n * It is supposed to be used as a regular JS object but has a hidden\n * property that holds the meta data of the document.\n *\n * That property is called `__meta__`, it should not be modified, and is non-enumerable.\n * It is used internally to identify the document when writing the\n * data to the database.\n */\nexport class Document {\n    constructor(rawDoc, db) {\n        if (db === undefined)\n            throw Error('Argument \"db\" is required but missing');\n        const { name, createTime, updateTime } = rawDoc;\n        const meta = {\n            db,\n            name,\n            createTime,\n            updateTime,\n            path: name.replace(db.rootPath, ''),\n            id: name.split('/').pop()\n        };\n        Object.defineProperty(this, '__meta__', { value: meta });\n        Object.assign(this, decode(rawDoc, db));\n    }\n}\n","import { Document } from './Document';\nimport { isRef, isPositiveInteger, encodeValue } from './utils';\n/** @private */\nconst operatorsMap = {\n    '<': 'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    '>': 'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    '==': 'EQUAL',\n    contains: 'ARRAY_CONTAINS',\n    'contains-any': 'ARRAY_CONTAINS_ANY',\n    in: 'IN'\n};\n/**\n * Checks if a value is a valid filter array.\n * @private\n */\nfunction validateFilter(filter) {\n    if (!Array.isArray(filter) || filter.length !== 3)\n        throw Error('Filter missing arguments');\n    const [fieldPath, op, value] = filter;\n    if (typeof fieldPath !== 'string')\n        throw Error('Invalid field path');\n    if (!(op in operatorsMap))\n        throw Error('Invalid operator');\n    if ((value === null || Number.isNaN(value)) && filter[1] !== '==')\n        throw Error('Null and NaN can only be used with the == operator');\n    if (value === undefined)\n        throw Error('Invalid comparative value');\n}\n/**\n * A map of functions used to encode each argument for a query.\n * Each function receives the Library arguments and returns an object\n * that will be converted to Json and sent to the Firestore REST API.\n * @private\n */\nconst encoders = {\n    /**\n     * Converts an option from the Query instance into a valid JSON\n     * object to use with the Firestores REST API.\n     */\n    select(fieldsArray) {\n        const fields = fieldsArray.map(fieldPath => ({ fieldPath }));\n        return fields.length ? { fields } : undefined;\n    },\n    /** Converts a Query filter(array with three items), into an encoded filter */\n    encodeFilter([fieldPath, op, value]) {\n        if (Number.isNaN(value) || value === null) {\n            return {\n                unaryFilter: {\n                    field: { fieldPath },\n                    op: Number.isNaN(value) ? 'IS_NAN' : 'IS_NULL'\n                }\n            };\n        }\n        return {\n            fieldFilter: {\n                field: { fieldPath },\n                op: operatorsMap[op],\n                value: encodeValue(value)\n            }\n        };\n    },\n    /**\n     * Converts an option from the Query instance into a valid JSON\n     * object to use with the Firestore's REST API.\n     */\n    where(option) {\n        if (option.length === 0)\n            return;\n        if (option.length === 1) {\n            return this.encodeFilter(option[0]);\n        }\n        // If there are more than one filters then this is a composite filter.\n        return {\n            compositeFilter: {\n                op: 'AND',\n                filters: option.map(this.encodeFilter)\n            }\n        };\n    },\n    /**\n     * When a startAt or endAt cursor is used,\n     * It is necessary to add a __name__ order at the end\n     * in order to make sure we start from the right spot.\n     */\n    orderBy(fields, options) {\n        var _a, _b, _c;\n        // Only add the __name__ order if a cursor was provided\n        // and if its is not already present.\n        if ((options.startAt || options.endAt) &&\n            ((_a = fields[fields.length - 1]) === null || _a === void 0 ? void 0 : _a.field.fieldPath) !== '__name__')\n            fields.push({\n                field: { fieldPath: '__name__' },\n                // Use the default order when there are no other fields,\n                // And if there are fields, use the order of the last one.\n                // This adheres to the spec at:\n                // https://firebase.google.com/docs/firestore/reference/rest/v1beta1/StructuredQuery\n                direction: (_c = (_b = fields[fields.length - 1]) === null || _b === void 0 ? void 0 : _b.direction) !== null && _c !== void 0 ? _c : 'ASCENDING'\n            });\n        return fields;\n    },\n    documentToCursor(doc, options) {\n        const values = [];\n        for (let order of options.orderBy) {\n            if (order.field.fieldPath === '__name__') {\n                values.push({ referenceValue: doc.__meta__.name });\n                continue;\n            }\n            const value = doc[order.field.fieldPath];\n            value && values.push(encodeValue(value));\n        }\n        return {\n            values,\n            before: true\n        };\n    },\n    startAt(doc, options) {\n        return this.documentToCursor(doc, options);\n    },\n    endAt(doc, options) {\n        return this.startAt(doc, options);\n    }\n};\n/** @private */\nconst queryOptions = [\n    'select',\n    'from',\n    'where',\n    'orderBy',\n    'startAt',\n    'endAt',\n    'offset',\n    'limit'\n];\n/**\n * Query class that represents a Firestore query.\n */\nexport class Query {\n    constructor(parent, init = {}) {\n        this.parent = parent;\n        this.options = {\n            select: [],\n            where: [],\n            orderBy: []\n        };\n        if (!isRef('doc', parent))\n            throw Error('Expected parent to be a reference to a document');\n        // Loop through all the valid options, validate them and then save them.\n        for (const option of queryOptions) {\n            const optionValue = init[option];\n            if (option in init) {\n                // If the option is \"where\" or \"orderBy\", and is also an array,\n                // then it might be a compound value, so we want to pass it one\n                // by one to its method.\n                //\n                // \"where\" is always an array, because every individual filter\n                // is represented by an array, so check to see if its first child\n                // is also an array. if it is, then it might be a compound value.\n                if ((option === 'where' && Array.isArray(optionValue[0])) ||\n                    (option === 'orderBy' && Array.isArray(optionValue))) {\n                    optionValue.forEach((val, i) => {\n                        // Use try/catch in order to provide context for the error.\n                        try {\n                            // Try to save the value.\n                            this[option](val);\n                        }\n                        catch (e) {\n                            throw Error(`Invalid argument \"${option}[${i}]\": ${e.message}`);\n                        }\n                    });\n                    continue;\n                }\n                // If the argument is not an array, then just save it directly.\n                // Again, we use try/catch to catch the error and add context to it.\n                try {\n                    this[option](optionValue);\n                }\n                catch (e) {\n                    throw Error(`Invalid argument \"${option}\": ${e.message}`);\n                }\n            }\n        }\n    }\n    select(fields) {\n        if (!Array.isArray(fields))\n            throw Error('Expected argument to be an array of field paths');\n        fields.forEach((field, i) => {\n            if (typeof field !== 'string')\n                throw Error(`Field path at index [${i}] is not a string`);\n            this.options.select.push(field);\n        });\n    }\n    /**\n     * Adds a collection to query.\n     */\n    from(from) {\n        let { collectionId = from, allDescendants } = from;\n        if (typeof collectionId !== 'string')\n            throw Error('Expected \"collectionId\" to be a string');\n        if (allDescendants !== undefined && typeof allDescendants !== 'boolean')\n            throw Error('Expected the \"allDescendants\" to be a boolean');\n        this.options.from = {\n            collectionId,\n            allDescendants\n        };\n        return this;\n    }\n    where(fieldPath) {\n        const filter = Array.isArray(fieldPath) ? fieldPath : arguments;\n        validateFilter(filter);\n        this.options.where.push(filter);\n        return this;\n    }\n    orderBy(order, dir = 'asc') {\n        const dirMap = {\n            asc: 'ASCENDING',\n            desc: 'DESCENDING'\n        };\n        let { field: fieldPath = order, direction = dir } = order;\n        direction = dirMap[direction];\n        if (typeof fieldPath !== 'string')\n            throw Error('\"field\" property needs to be a string');\n        if (direction === undefined)\n            throw Error('\"direction\" property can only be \"asc\" or \"desc\"');\n        this.options.orderBy.push({ field: { fieldPath }, direction });\n        return this;\n    }\n    startAt(doc) {\n        if (!(doc instanceof Document))\n            throw Error('Expected a Document instance');\n        this.options.startAt = doc;\n        return this;\n    }\n    endAt(doc) {\n        if (!(doc instanceof Document))\n            throw Error('Expected a Document instance');\n        this.options.endAt = doc;\n        return this;\n    }\n    offset(number) {\n        if (!isPositiveInteger(number))\n            throw Error('Expected an integer that is greater than 0');\n        this.options.offset = number;\n        return this;\n    }\n    limit(number) {\n        if (!isPositiveInteger(number))\n            throw Error('Expected an integer that is greater than 0');\n        this.options.limit = number;\n        return this;\n    }\n    async run() {\n        var _a;\n        let results = await this.parent.db.fetch(this.parent.endpoint + ':runQuery', {\n            method: 'POST',\n            body: JSON.stringify(this)\n        });\n        ((_a = results[0]) === null || _a === void 0 ? void 0 : _a.document) || results.splice(0, 1);\n        return results.map((result) => new Document(result.document, this.parent.db));\n    }\n    toJSON() {\n        const encoded = {};\n        for (const option in this.options) {\n            const optionValue = this.options[option];\n            if (option in encoders) {\n                encoded[option] = encoders[option](optionValue, this.options);\n                continue;\n            }\n            encoded[option] = optionValue;\n        }\n        return {\n            structuredQuery: encoded\n        };\n    }\n}\n","import { Document } from './Document';\n/**\n * Represents a collection list response, with functionality\n * for getting the next page when available.\n * @param {Object} rawList The response \"raw\" list object.\n * @param {Reference} ref A reference to the collection.\n * @param {Object} options Any options that were passed at first to the get request.\n */\nexport class List {\n    constructor(rawList, ref, options = {}) {\n        if (ref === undefined)\n            throw Error('The \"reference\" argument is required when creating a List');\n        if (!ref.isCollection)\n            throw Error('The reference in a list should point to a collection');\n        const { documents, nextPageToken } = rawList;\n        this.ref = ref;\n        this.options = options;\n        this.documents = documents\n            ? documents.map(rawDoc => new Document(rawDoc, ref.db))\n            : [];\n        this.options.pageToken = nextPageToken;\n    }\n    /** Fetches the next page in the query */\n    getNextPage() {\n        return this.ref.list(this.options);\n    }\n    [Symbol.iterator]() {\n        // Use a new index for each iterator. This makes multiple\n        // iterations over the iterable safe for non-trivial cases,\n        // such as use of break or nested looping over the same iterable.\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.documents.length) {\n                    return { value: this.documents[index++], done: false };\n                }\n                else {\n                    return { done: true };\n                }\n            }\n        };\n    }\n}\n","import { Query } from './Query';\nimport { Document } from './Document';\nimport { List } from './List';\nimport { trimPath, isPath, objectToQuery, restrictTo, compileOptions } from './utils';\nexport class Reference {\n    constructor(path, db) {\n        var _a;\n        this.db = db;\n        if (typeof path !== 'string')\n            throw Error('The \"path\" argument should be a string');\n        // Normalize the path by removing slashes from\n        // the beginning or the end and trimming spaces.\n        path = trimPath(path);\n        this.id = (_a = path.split('/').pop()) !== null && _a !== void 0 ? _a : '';\n        this.path = path;\n        this.name = `${db.rootPath}/${path}`;\n        this.endpoint = `${db.endpoint}/${path}`;\n        this.isRoot = path === '';\n    }\n    /** Returns a reference to the parent document/collection */\n    get parent() {\n        if (this.isRoot)\n            throw Error(\"Can't get the parent of root\");\n        return new Reference(this.path.replace(/\\/?([^/]+)\\/?$/, ''), this.db);\n    }\n    /** Returns a reference to the parent collection */\n    get parentCollection() {\n        if (this.isRoot)\n            throw Error(\"Can't get parent of a root collection\");\n        if (this.isCollection)\n            return new Reference(this.path.replace(/(\\/([^/]+)\\/?){2}$|^([^/]+)$/, ''), this.db);\n        return this.parent;\n    }\n    /** Returns true if this reference is a collection */\n    get isCollection() {\n        return isPath('col', this.path);\n    }\n    /** Returns a reference to the specified child path */\n    child(path) {\n        // Remove starting forward slash\n        path = path.replace(/^\\/?/, '');\n        // Return a newly created document with the new sub path.\n        return new Reference(`${this.path}/${path}`, this.db);\n    }\n    async transact(method, obj, options = {}) {\n        const tx = this.db.transaction();\n        const res = tx[method](this, obj, options);\n        return await tx.commit().then(() => res);\n    }\n    /** Returns all documents in the collection */\n    async list(options = {}) {\n        restrictTo('col', this);\n        return new List(await this.db.fetch(this.endpoint + objectToQuery(compileOptions(options))), this, options);\n    }\n    /** Returns the document of this reference. */\n    async get(options = {}) {\n        restrictTo('doc', this);\n        return new Document(await this.db.fetch(this.endpoint + objectToQuery(compileOptions(options))), this.db);\n    }\n    /** Create a new document with a randomly generated id */\n    async add(obj, options = {}) {\n        restrictTo('col', this);\n        return this.transact('add', obj, options);\n    }\n    /** Create a new document or overwrites an existing one matching this reference. */\n    async set(obj, options = {}) {\n        restrictTo('doc', this);\n        return this.transact('set', obj, options);\n    }\n    /** Updates a document while ignoring all missing fields in the provided object. */\n    async update(obj, options = {}) {\n        restrictTo('doc', this);\n        return this.transact('update', obj, options);\n    }\n    /** Deletes the referenced document from the database. */\n    async delete(options = {}) {\n        restrictTo('doc', this);\n        return this.transact('delete', options);\n    }\n    /** Queries the child documents/collections of this reference. */\n    query(options = {}) {\n        restrictTo('col', this);\n        return new Query(this.parent, {\n            from: {\n                collectionId: this.id\n            },\n            ...options\n        });\n    }\n    toJSON() {\n        return {\n            referenceValue: this.name\n        };\n    }\n}\n","import { compileOptions, encode, fid, getPathFromRef, restrictTo } from './utils';\nimport { Document } from './Document';\nexport class Transaction {\n    constructor(db) {\n        this.db = db;\n        this.writes = [];\n        this.preconditions = {};\n    }\n    /**\n     * Creates a write instruction and adds it into the\n     * transaction writes array.\n     * @private\n     */\n    write(ref, data, options = {}) {\n        if (typeof data !== 'object')\n            throw Error('The data argument is missing');\n        const transforms = [];\n        const name = `${this.db.rootPath}/${getPathFromRef(ref)}`;\n        const precondition = this.preconditions[name];\n        // Compile the JS Object into a Firebase Document.\n        const doc = encode(ref instanceof Document ? ref : data, transforms);\n        // Compile the options object into Firebase API arguments.\n        options = compileOptions(options, data);\n        // Check if there is any precondition created by getting a document\n        // as part of this transaction, and if there is then use it.\n        precondition && (options.currentDocument = precondition);\n        // Set the document's name\n        doc.name = name;\n        // Add the static properties.\n        this.writes.push({\n            update: doc,\n            ...options\n        });\n        // Add the Transforms if available.\n        transforms.length &&\n            this.writes.push({\n                transform: {\n                    document: doc.name,\n                    fieldTransforms: transforms\n                }\n            });\n    }\n    /**\n     * Wraps batch get with additional functionality needed in transactions.\n     * Transactions need to be atomic. So in order to know that the document\n     * wasn't changed concurrently then we save the updateTime of each document.\n     *\n     * Later we tell the database to use that as a precondition for the write.\n     * In other words, if the update time of a document changed, then abort\n     * the transaction. However, if a document didn't exist, then we use that\n     * as a precondition, telling the database that if it was created concurrently\n     * then it should abort the operation.\n     */\n    async get(refs) {\n        const docs = await this.db.batchGet(refs);\n        docs.forEach((doc) => {\n            const { name, updateTime } = doc.__meta__ || { name: doc.__missing__ };\n            this.preconditions[name] = updateTime\n                ? { updateTime }\n                : { exists: false };\n        });\n        return docs;\n    }\n    add(ref, data, options = {}) {\n        const path = `${restrictTo('col', ref)}/${fid()}`;\n        this.write(path, data, { exists: false, ...options });\n        return this.db.ref(path);\n    }\n    set(ref, data, options = {}) {\n        restrictTo('doc', ref);\n        this.write(ref, data, options);\n    }\n    update(ref, data, options = {}) {\n        restrictTo('doc', ref);\n        this.write(ref, data, { exists: true, updateMask: true, ...options });\n    }\n    /**\n     * Adds a delete operation to the transaction.\n     */\n    delete(ref, options = {}) {\n        const name = `${this.db.rootPath}/${restrictTo('doc', ref)}`;\n        options = compileOptions(options);\n        // Check if there is any precondition created by getting a document\n        // as part of this transaction, and if there is then use it.\n        this.preconditions[name] &&\n            (options.currentDocument = this.preconditions[name]);\n        this.writes.push({\n            delete: name,\n            ...options\n        });\n    }\n    /**\n     * Commits the transaction.\n     * Will throw if the transaction failed.\n     */\n    async commit() {\n        this.preconditions = {};\n        return void (await this.db.fetch(this.db.endpoint + ':commit', {\n            method: 'POST',\n            body: JSON.stringify({ writes: this.writes })\n        }));\n    }\n}\n","import { Database } from \"firebase-firestore-lite\";\nimport { IDbSurvey, ISurveyData } from \"./db\";\n\nexport const db = new Database({ projectId: \"thucdia-e52ff\" });\nconst db_prefix = process.env.NODE_ENV === \"production\" ? \"prod\" : \"dev\";\n\nexport type RemoteData =\n  | { type: \"survey\"; payload: IDbSurvey }\n  | { type: \"surveyData\"; payload: ISurveyData }\n  | { type: \"surveyRevision\"; payload: ISurveyData };\n\nconst upsertSurvey = async (type: \"survey\", payload: IDbSurvey, machineId: string) => {\n  const ref = db.ref(`${db_prefix}--${type}/${payload.surveyId}`);\n\n  const { syncStatus, ...content } = payload;\n\n  const doc = await ref.set({ ...content, machineId });\n  return doc;\n};\n\nconst upsertData = async (type: \"surveyData\" | \"surveyRevision\", payload: ISurveyData, machineId: string) => {\n  const ref = db.ref(`${db_prefix}--${type}/${payload.surveyDataId}`);\n\n  const { syncStatus, ...content } = payload;\n\n  const doc = await ref.set({ ...content, machineId });\n  return doc;\n};\n\nexport const upsert = async (data: RemoteData, machineId: string) => {\n  switch (data.type) {\n    case \"survey\":\n      return await upsertSurvey(data.type, data.payload, machineId);\n    case \"surveyData\":\n    case \"surveyRevision\":\n      return await upsertData(data.type, data.payload, machineId);\n  }\n};\n","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"wrapper__1x8n1\",\"header\":\"header__3tjqy\",\"syncStatus\":\"syncStatus__29ty1\"};","import { makeId } from \"../db/db\";\n\nconst key = \"voser__machineId\";\n\nexport const useMachineId = () => {\n  const ls = window.localStorage.getItem(key);\n  if (!ls) {\n    const id = makeId();\n    window.localStorage.setItem(key, id);\n    return id;\n  } else {\n    return ls;\n  }\n};\n"],"sourceRoot":""}